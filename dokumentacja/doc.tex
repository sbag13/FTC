\documentclass[12pt, notitlepage]{article}

\usepackage{geometry}
\usepackage{polski}
\usepackage[utf8]{inputenc}
\usepackage[T1]{fontenc}
\usepackage{enumitem}
\usepackage{graphicx}
\usepackage{float}
\usepackage{listings}
\usepackage{url}
\lstset{basicstyle=\footnotesize\ttfamily,breaklines=true}

\usepackage{etoolbox}
\makeatletter
\patchcmd{\chapter}{\if@openright\cleardoublepage\else\clearpage\fi}{}{}{}
\makeatother

\usepackage[toc]{appendix}
\renewcommand{\appendixtocname}{Dodatki}
\renewcommand\refname{Odwołania}
\usepackage[parfill]{parskip}
% \setlength{\parindent}{0pt}
% \setlength{\parskip}{\baselineskip}

% \usepackage[
%     backend=biber,
%     style=alphabetic,
%     sorting=ynt
%     ]{biblatex}

% \addbibresource{doc.bib}
\geometry{legalpaper, margin=0.8in}

\begin{document}

\begin{titlepage}
    \thispagestyle{empty}
    \title{\textbf{\Huge Systemy bezpieczne i FTC \\[1cm]\LARGE Wiarygodność systemów w pracy zespołowej - \\ jak czynnik ludzki wpływa na różnice w implementacji specyfikacji}}
    \author{Szymon Bagiński \\ Artur Walasz \\[1cm]{\small Prowadzący: Mgr inż. Tomasz Serafin}}
    % \author{Szymon Bagiński\thanks{funded by the ShareLaTeX team}}
    \date{Styczeń 2018}
    \maketitle
    \vfill
    % \renewcommand{\chapter}[2]{}
    \begin{center}
        \Large \bfseries\contentsname
    \end{center}
    \tableofcontents
    \vfill
\end{titlepage}    

% \chapter{Wstęp}
% \addcontentsline{toc}{chapter}{Wstęp}

\section{Wstęp}

\subsection{Cel projektu}

Wykorzystywanie nawet najlepszego oprogramowania, w którym zaimplementowano najbardziej zaawansowane technologie i najbezpieczniejsze algorytmy, nie jest w stanie zapewnić systemowi 100-procentowego bezpieczeństwa. Dzieje się tak dlatego, że w rozwoju i implementacji oprogramowania uczestniczą ludzie, którzy z natury mają skłonność do popełniania błędów. W rezultacie, ludzie, którzy są częścią systemu, zawsze będą najsłabszym ogniwem bezpieczeństwa systemu. Czynnik ludzki jest głównym powodem, dla którego udaje się tak wiele ataków na komputery i systemy.

Celem tego projektu było zbadanie wpływu czynnika ludzkiego na różne implementacje tej samej specyfikacji. W jego ramach stworzono dwie niezależne implementacje oprogramowania z jednolitym, ustandaryzowanym interfejsemm, sposobem testowania oraz wymaganiami funkcjonalnymi. Na ich podstawie wyciągnięto wnioski na temat tego, jak indywidualne podejście, interpretacja dostarczonych wymagań oraz wybór technologii wpływają na finalną wersję wytworzonego produktu.

\subsection{Realizacja}

Punktem wyjściowym do projektu było stworzenie wspólnej specyfikacji wymagań projektowych oraz zbioru testów akceptacyjnych \cite{tests} prostego serwisu aukcyjnego w architekturze klient-serwer.

Na potrzeby projektu zdefiniowano specyfikację interfejsu serwisu uwzględniającą następujące funkcje:
\begin{itemize}
    \item Rejestracja użytkowników
	\item Logowanie użytkowników
	\item Tworzenie ofert typu:
    \begin{itemize}
		\item akucja: ``auction''
		\item teraz: ``buynow''
    \end{itemize}
	\item Kupowanie / licytacja twoarów (ofert) przez użytkowników
    \item Przeglądanie ofert z filtracją
    \begin{itemize}
        \item opis zawiera tekst zadany tekst
        \item cena minimalna
        \item cena maksymalna
        \item ilość dostępnych przedmiotów
    \end{itemize}
	\item Przeglądanie własnych ofert
    \item Obsługa własnych ofert:
    \begin{itemize}
		\item modyfikacja ofert
        \item usówanie ofert
    \end{itemize}
\end{itemize}

Specyfikacja zawiera opis wszystkich wymaganych endpointów (dodatek \ref{app:endpoints}), w tym:
\begin{itemize}
    \item adres url
    \item dozwolone metody HTTP
    \item wymagany format danych, które powinny zostać przesłane w zapytaniach POST
    \item oczekiwane statusy odpowiedzi w zależności od warunków
\end{itemize}

Dokładne wymagania dla konkretnych funkcji serwizu zostaną opisane w dalszej części dokumentacji. Porównane zostaną obydwie implementacjie pod kątem zgodności z dokumentacjią oraz ze sobą wzajemnie.

\section{Porównanie implementacji}

\subsection{Wybór technologii}

Podstawową różnicą między dwiema powstałymi implementacjami jest użyta technologia. Każde z rozwiązań posiada oczywiście inny zestaw cech, niektóre rzeczy wykonuje się łatwiej kosztem innych. Każda z nich ma także inne ograniczenia, czy zachowania domyślne. Wybór ten zatem mocno rzutuje na różnice, które będą widoczne przy konkretnych funkcjach systemu, bądź na nakład pracy jaki trzeba włożyć przy spełnianiu konkretnych wymagań.

\subsubsection{Implementacja 1}

Do pierwszej implementacji postanowiono użyć języka programowania Rust \cite{rust}. Jest to kompilowalny język stworzony z myślą o tworzeniu stabilnych, bezpiecznych, i przede wszystkim wydajnych aplikacji.

Do stworzenia aplikacji, korzystającej z protokołu HTTP, skorzystano z biblioteki Rocket \cite{rocket}. Jest to bardzo wygodne rozwiązanie. W połączeniu z menedżerem pakietów Cargo, pierwszą najprostszą aplikację można stworzyć w kilka minut. Rozszerzanie jej o kolejne funkcjonalności również nie przyspaża żadnych problemów. Jednocześnie zapewnia ona bezpieczeństwo danej aplikacji, elastyczność a przedwszystkim stabilność (m. in. poprzez ``type safety''). W połączeniu z ogólnymi cechami języka Rust daje nam to duże prawdopodobieństwo, że skompilowany program, będzie działał bez problemów przez długi czas.

Kod źródłowy można znaleźć pod poniższym linkiem:\\
\centerline{\url{https://github.com/sbag13/FTC/tree/master/baginski}}

\subsubsection{Implementacja 2}

W drógiej implementacji postanowiono wykorzystać język Python. W języku tym dostępnych jest kilka frameworków pozwalających na stworzenie aplikacji webowej, są to między innymi:
\begin{itemize}
    \item Tornado
    \item Flask
    \item Django
\end{itemize}

Na potrzeby projektu zdecydowano się wykorzystać framework Django, który opiera się o wzorzec architektoniczny model-template-view. Zakres implementacji określał jedynie zbudowanie interfejsu w protokole HTTP (Web API), dlatego pełne możliwości fremeworku nie zostały wykorzystane. Niemniej jednak odseparowanie logiki biznesowej od modeli w bazie danych oraz łatwość zarządzenia tymi modelami przeważyła nad wyborem właśnie tego frameworku. W implementacji wykorzystano ponadto narzędzie Django REST framework \cite{django_rest_framework}, które w znacznym stopniu ułatwia tworzenie Web API. Django REST framework dostarcza wielu gotowych generycznych widoków, które zapewniają na przykład wzorzec CRUD dla danego obiektu, czy też pozwalają na wyświetlanie całych list obiektów w formie zdefiniowanej przez dostarczoną klasę Serializera.

\subsection{Rejestracja} \label{sec:rejestracja}

Mogłoby się wydawać, że tak prosty \textsl{endpoint} jak rejestracja nie powinien spowodować dużych rozbieżności. Niemniej jednak niedociągnięcia specyfikacji pozostawiają pole do różnych interpretacji.\\
Specyfikacja określała, że do rejestracji użytkownika potrzebne jest wysłanie zapytania POST które w swoim ciele zawiera strukturę JSON z dwoma polami: "mail" oraz "password". Wartość pola "mail" musi być oczywiście niepowtarzalna. Istniej zatem możliwość aby użyć jej jako identfikatora danego użytkownika, zarówno w bazie danych jak i w aplikacji. Postanowiono tak zrobić w implementacji 1., gdzie mail jest kluczem pierwotnym dla użytkownika. W implementacji 2. identyfikatorem użytkownika jest dymyśnie klucz <id: int>, na adres email narzucono jedynie warunek jego unikalności. \\
W implementacji 2. natknięto się na istotny problem. Framework Django dostarcza domyślną obsługę modelu użytkownika. Problem polega na tym, że zdefiniowany specyfikacji sposób reprezentacji użytkownika wymagał wprowadzenia bardzo wielu czasochłonnych zmian. Samo wprowadzenie niestandardowego modelu nie jest skomplikowane, ale dostosowanie pozostałych gotowych wteczek, które tego modelu używają już tak. Problem zostanie opisany dalej w sekcji \ref{sec:logowanie}. We frameworku Django dostępna jest klasa AbstractUser którą można wykorzystać w celu zdefiniowania niestandardowego użytkownika. Podczas rejestracji należało też nadpisać zachowanie się serwera. Domyślnie rejestracja wymagała wysłania zapytania POST ze strukturą JSON z następującymi polami: "username", "email", "password1" oraz "password2". Wynika z tąd wniosek, że specyfikacja zniosła domyślne zabezpieczenie obecne w wielu serwiasch, które polega na dwukrotnym podaniu jednakowego hasła w celu uniknięcia błędów podczas jego wpisywania. W naszych implementacjach wysłanie zapytania z niezamierzenie błędnym hasłem spowoduje, że użytkownik nie zostanie o tym fakcie poinformowany i nie będzie w stanie zalogować się na swoje konto. Specyfikacja nie zakładała wprowadzenia mechanizmu zmiany haseł użytkowników. \\
Następnie należy rozpatrzyć przypadek, którego specyfikacja nie określa jednoznacznie. Gdy nie uda się poprawnie zinterpretować przesłanych danych jako JSON, bibliotek Rocket obsłuży taki przypadek wysyłając status 422 (Unprocessable Entity). W implementacji 2, serwer django zwraca kod 415 wraz z informacją: \textit{'Unsupported media type "text/plain" in request.'} jeśli podano zły nagłówek Content-Type. Jeśli nagłówek jest poprawny, czyli ma wartość "application/json", to kod odpowiedzi jest zgodny z wymienionym w specyfikacji kodem 400 (Bad Request).  \\
Wszystkie wymienione wyżej kody odpowiedzi dla zaistniałej sytaucji są prawidłowe, ponieważ ich interpretacja jest, jak w przypadku wielu innych kodów odpowiedz HTTP, kwestią subiektywną i silnie zależy od indywidualnej interpretacji. Z tego powodu projektując system należy zwrócić szczególną uwagę na zdefiniowanie zachowania Web API dla wszystkich potencjalnych sytuacji, zwłacza, jeśli bazując na kodzie odpowiedzi aplikacja wykorzystująca dane API będzie podejmowała konkretne działania. \\
Specyfikacja określa co powinno się stać gdy zapytanie zostanie wysłane poprawnie za pomocą innej niż POST metody HTTP. W takim przypadku powinien zostać zwrócony status 405 (Method Not Allowed). W przypadku implementacji 1. skutkuje to bardzo dużym nakładem mało istotnej pracy. Rocket, gdy nie uda mu się dopasować żadnego istniejącego endpointu, wysyła domyślnie status 404 (Not Found). Dzieje się tak również w przypadku gdy nie znajdzie odpowiedniej metody HTTP, nawet jeśli reszta parametrów się zgadza. Aby otrzymać zgodność ze specyfikacją należałoby więc utworzyć endpointy dla wszystkich możliwych metod protokołu HTTP, których jedyną odpowiedzialnością byłoby wysłanie błędu o statusie 405. W implementacji 1. zdecydowano się nadpisać tylko metody get, put oraz delete.
W implementacji 2. w przypadku wykorzystania generycznych widoków problem jest rozwiązany automatycznie. Wysłanie zapytania z niezdefiniowaną metodą HTTP dla zarejestrowanego adresu url zawsze skutkuje zwróceniem statusu 405, chyba, że zachowanie to zastanie świadomie nadpisane.

\subsection{Logowanie}\label{sec:logowanie}

Przy implementacji logowania napotkano problemy opisane w sekcji \ref{sec:rejestracja}. Podczas tworzenia specyfikacji postanowiono, że do uwierzytelniania będą wykorzystywane tokeny JWT (JSON Web Token) \cite{jwt}. Jest to jednak elastyczna struktura i jej elementy nie zostały jednoznacznie określone. \\
W przypadku implementacji 1. nagłówek JWT został wygenerowany w sposób domyślny, który używa algorytmu HS256, a ładunkiem tokena zostało tylko pole mail danego użytkownika. W żaden sposób nie został określony czas ważności sesji. Rażącym niedopatrzeniem podczas tworzenia dokumentacji jest także fakt, że nie pomyślano o funkcji wylogowywania. Aby usunąć sesję należy więc zalogować się na konto innego użytkownika albo usunąć pliki ``cookies'' z przeglądarki.  \\
W przypadku implementacji 2. skorzystano z zestawu gotowych aplikacji które zostały podpięte do projektu między innymi: 
\begin{itemize}
    \item rest\_framework\_jwt.authentication.JSONWebTokenAuthentication
    \item allauth.account
\end{itemize}
Oraz inne aplikacje od których powyższe są zależne. Gotowe rozwiązanie dostarcza mechanizmy do generacji tokenów (logowania) jak i też wylogowywania. Tutaj pojawił się wspomniany w poprzedniej sekcji \ref{sec:rejestracja} problem z modelem użytkownika. Gotowe aplikacjie posiadają wiele ustawień, które należało odpowiednio sparametryzować, by autentykacja odbywała się za pomocą pola "mail". Domyślnie wykorzystywanym polem jest pole "username", które pierwotnie zostało całkowicie usunięte. Aplikacje o których mowa, pomimo że potrafią za pomocą odpowiednich ustawień zmienić motodę autentykacji na pole "mail", do prawidłowego działania wciąż potrzebowały pola "username". Znalezienie problemu i jego rozwiązania było najcięższym problemem w implementacji 2. Projekt był przepisywany trzykrotnie, aby sprostać postawionym w specyfikacji wymaganiom. Finalnie pole username jest sztucznie dodawane do modelu użytkownika, ale zawsze jest ono puste i nigdzie nie jest wykorzystywane.  \\
W implementacji 2. nie przewidziano umieszczania tokena JWT w plikach ``cookies'' przeglądarki, ponieważ wszystkie testy wykonywane były z poziomu frameworku pytest, lub za pomocą narzędzia Postman.

\subsection{Tworzenie ofert}

<TODO> to tylko draft. <todo>
Opis w specyfikacji, \\
- zalogowany użytkownik \\
- ujemna cena - wynika z testow akceptacyjnych
- ujamna ilosc - wynika z testow akceptacyjnych

- aukcja - cena minimalna -> niejednoznacznosc w dokumentacji

- nadmiarowe pola - serializer jes odrzuca nie generujac bledu. Sprawdzane jest domyslnie tylko to, czy potrzebne pola sa zawarte. Powinno byc 400 wg. specyfikacji



\subsection{Kupowanie / licytacja}
\subsection{Przeglądanie ofert wraz z filtrowaniem}

\section{Podsumowanie}

\begin{thebibliography}{9}

\bibitem{jwt}
\textit{JSON Web Tokens} [online], Data dostępu: 12.01.2019. 
\newline\url{https://jwt.io/}

\bibitem{tests}
\textit{Opis testów funkcji systemu} [online], Data dostępu: 12.01.2019. 
\newline\url{https://drive.google.com/drive/folders/194qvJLmUYSD427WfbAkm365Q3SCY1ZaY}.

\bibitem{rocket}
\textit{Rocket - Simple, Fast, Type-Safe Web Framework for Rust} [online], Data dostępu: 12.01.2019. 
\newline\url{https://rocket.rs/}.

\bibitem{rust}
\textit{Rust} [online], Data dostępu: 12.01.2019. 
\newline\url{https://www.rust-lang.org/}.

\bibitem{django_rest_framework}
\textit{Django REST framework} [online], Data dostępu: 12.01.2019. 
\newline\url{https://www.django-rest-framework.org/}.

\end{thebibliography} 


\newpage
\setlength\parindent{24pt}
\begin{appendices}
\section{Interfejs serwisu aukcyjnego} \label{app:endpoints}
\footnotesize
\texttt{
/registration \\
POST \\
\{\\
\indent mail: \indent		string,\\
\indent	password:	string\\
\}\\
\\
201 - Created (pomyślne utworzenie użytkownika)\\
400 - Bad Request (np. zły email)\\
409 - Conflict (konto istnieje)\\
500 - Internal Server Error\\
503 - Server Unavaiable (powód podany w opisie)\\
\\
not POST \\
405 - Method Not Allowed 
\\ ---------------------------------------------------------------------------------------------------------------------------------
\\
/login\\
POST \\
\{\\
\indent    mail:	\indent	string,\\
\indent    password:	string\\
\}\\
\\
200 - OK, (JWT token in response)\\
401 - Unauthorized\\
404 - Not Found\\
500 - Internal Server Error\\
503 - Server Unavaiable (powód podany w opisie)\\
\\
not POST\\
405 - Method Not Allowed\\
---------------------------------------------------------------------------------------------------------------------------------\\
/offers\\
POST\\
\{\\
\indent type*: \ \ \ \ \ \ \ \lbrack auction|buynow\rbrack,\\
\indent	description*:	string,\\
\indent	price*:	\ \ \ \ \ \ float, (cena min. - akcja; cena za sztukę - kup teraz),\\
\indent	date*:\ \ \ \ \ \ \ \ 	timestamp, (sekundy, tylko dla aukcji),\\
\indent	amount*: \ \ \ \ \ int (tylko dla kup teraz)\\
\}\\
\\
201 - added \\
	\{\\
    	\indent offer\_id: int\\
	\}\\
400 - Bad Request (niepoprawny JSON, brakujące lub nadmiarowe pola)\\
401 - Unauthorized (niezalogowany użytkownik)\\
403 - Forbidden (zalogowany na nieuprawnione konto)\\
500 - Internal Server Error\\
503 - Server Unavaiable (powód podany w opisie)\\
\\
GET\\
Dozwolone filtry w url:\\
- contains - pole description zawiera ciąg znaków\\
- price\_min - minimalna cena towaru (i aukcji)\\
- price\_max - maksymalna cena towaru (i aukcji)\\
- type - [auction/buynow] - typ oferty\\
- created\_by\_me: boolean\\
\\
200 - (oferty w odpowiedzi - może być pusta "\lbrack\rbrack")\\
400 - Bad Request (niepoprawny filtr w url)\\
500 - Internal Server Error\\
503 - Server Unavaiable (powód podany w opisie)\\
---------------------------------------------------------------------------------------------------------------------------------\\
/offers/\{id\}\\
PATCH\\
\{\\
\indent    **fields\_to\_modify...\\
\}\\
\\
użytkownik może modyfikować:\\
- price, amount, description - dla ofert typu "buynow"\\
- price, description -  dla ofert typu "auction"\\
\\
202 - Accpepted\\
400 - Bad Request\\
403 - Unauthorized\\
404 - Not Found (nie znaleziono ofert)\\
\\
DELETE\\
(no payload)\\
202 - Accepted\\
403 - Unauthorized\\
404 - Not Found (nie znaleziono oferty)\\
\\
GET\\
(no payload)\\
200 - Ok (w odpowiedzi szczegóły aukcji)\\
\{	\\
\indent    type: \ \ \ \ \ \ \ \ \ "auction",\\
\indent    description: \ \ "opis",\\
\indent    status: \ \ \ \ \ \ \ [active / expired],\\
\indent    last\_bid: \ \ \ \ \ float,\\
\indent    customer\_id: \ \ int,\\
\indent    expiration\_ts: <timestamp>\\
\}\\
200 - Ok (szczegóły oferty "buynow")\\
\{	\\
\indent type: \ \ \ \ \ \ \ "buynow",\\
\indent description: string,\\
\indent	price: \ \ \ \ \ \ int,        \\
\indent	amount: \ \ \ \ \ int\\
\}\\
404 - Not Found\\
---------------------------------------------------------------------------------------------------------------------------------\\
/offers/\{id\}/buy\\
POST\\
\{\\
\indent    bid: \ \ \  int (auction)\\
\indent    amount:	int (buynow)\\
\}\\
\\
202 - Accepted\\
400 - Bad Request (niepoprawny JSON, brakujące lub nadmiarowe pola)\\
401 - Unauthorized (niezalogowany użytkownik)\\
409 - Conflict:\\
\indent	409 - \{"minimal\_bid": <minimalny bid>\}\\
\indent	409 - \{"max\_amout": <ilość dostępnych produktów>\}\\
\indent	409 - \{"status": "expired"\}\\
\indent	409 - \{"conflict": "unable to order own items"\}\\
\indent	409 - \{"conflict": "you can not bid on the auction you win"\}\\
500 - internal server error\\
503 - Server Unavaiable (powód podany w opisie)\\
}

\end{appendices}

\end{document}